rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user belongs to a specific institute
    // IMPORTANT: Admin IS the user - anyone in institutes/{instituteId}/users/{uid} is an admin of that institute
    // TESTING PHASE: Approval check removed - all users in institute can access
    function belongsToInstitute(instituteId) {
      return isAuthenticated() && (
        exists(/databases/$(database)/documents/institutes/$(instituteId)/users/$(request.auth.uid)) ||
        (
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin' &&
          (
            get(/databases/$(database)/documents/users/$(request.auth.uid)).data.instituteId == instituteId ||
            get(/databases/$(database)/documents/users/$(request.auth.uid)).data.instituteId == null
          )
        )
      );
    }
    
    // Helper function to check if user is main admin (super admin control panel)
    function isMainAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/main_admins/$(request.auth.uid));
    }

    // Helper function to check super admin role via coders collection
    function isSuperAdmin() {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/coders/$(request.auth.uid)) &&
        (
          get(/databases/$(database)/documents/coders/$(request.auth.uid)).data.isSuperAdmin == true ||
          get(/databases/$(database)/documents/coders/$(request.auth.uid)).data.role == 'super_admin' ||
          get(/databases/$(database)/documents/coders/$(request.auth.uid)).data.role == 'superadmin'
        );
    }

    function isPlatformAdmin() {
      return isMainAdmin() || isSuperAdmin();
    }

    // Helper function to validate GPS config document
    function isValidGpsConfigData(data, instituteId) {
      return data.latitude is number &&
             data.latitude >= -90 && data.latitude <= 90 &&
             data.longitude is number &&
             data.longitude >= -180 && data.longitude <= 180 &&
             data.radius is number &&
             data.radius >= 10 && data.radius <= 10000 &&
             (data.instituteId == null || data.instituteId == instituteId) &&
             (data.adminId == null || data.adminId is string) &&
             (data.isLocked == null || data.isLocked is bool) &&
             (data.lockedBy == null || data.lockedBy is string);
    }

    // Helper function to validate email format
    function isValidEmail(email) {
      return email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }

    // Helper function to validate string length
    function isValidLength(str, minLen, maxLen) {
      return str is string && str.size() >= minLen && str.size() <= maxLen;
    }

    // Helper function to validate roll number format
    function isValidRollNumber(rollNumber) {
      return rollNumber is string && 
             rollNumber.matches('^[A-Za-z0-9_-]{1,20}$');
    }

    // Helper function to validate name format
    function isValidName(name) {
      return name is string && 
             name.size() >= 2 && 
             name.size() <= 100 &&
             name.matches('^[a-zA-Z\\s\\.]{1,100}$');
    }

    // Helper function to validate institute data
    function isValidInstituteData(data) {
      return isValidLength(data.name, 2, 100) &&
             isValidLength(data.instituteId, 1, 50) &&
             data.instituteId.matches('^[A-Za-z0-9_-]{1,50}$');
    }

    // Helper function to validate student data
    function isValidStudentData(data) {
      // Check required fields exist and are valid
      return data.name is string &&
             isValidName(data.name) &&
             data.userId is string &&
             isValidRollNumber(data.userId) &&
             // Optional batchName - allow null, empty string, or valid length
             (data.batchName == null || 
              (data.batchName is string && 
               (data.batchName.size() == 0 || isValidLength(data.batchName, 1, 50)))) &&
             // Optional email - allow null, empty string, or valid email format
             (data.email == null || 
              (data.email is string && 
               (data.email.size() == 0 || isValidEmail(data.email))));
    }

    // Helper function to validate attendance data
    function isValidAttendanceData(data) {
      // Required fields: rollNumber and subject must be valid strings
      // Timestamp validation: serverTimestamp() sentinels are handled by Firestore
      // We check if timestamp exists (it will be converted to timestamp on server)
      return data.rollNumber is string &&
             isValidRollNumber(data.rollNumber) &&
             data.subject is string &&
             isValidLength(data.subject, 1, 50) &&
             // Timestamp: can be timestamp type or serverTimestamp sentinel (Firestore handles conversion)
             // We just check that the field exists - Firestore will convert serverTimestamp() to actual timestamp
             data.keys().hasAny(['timestamp']) &&
             // Optional fields
             (data.photoUrl == null || (data.photoUrl is string && data.photoUrl.size() > 0)) &&
             (data.studentName == null || (data.studentName is string && isValidName(data.studentName))) &&
             (data.date == null || (data.date is string && data.date.size() > 0));
    }
    
    // ========== MAIN ADMINS COLLECTION ==========
    match /main_admins/{adminId} {
      // Main admin can read their own data
      allow read: if isAuthenticated() && request.auth.uid == adminId;
      // Only server/admin SDK can write (for security)
      allow write: if false;
    }
    
    // ========== INSTITUTES COLLECTION ==========
    match /institutes/{instituteId} {
      // Institute document - readable by anyone (authenticated or not) for search
      // This allows users to search institutes before registration
      // allow read covers both document reads and collection queries
      allow read: if true;
      // ONLY main admin (super admin) can create institutes
      allow create: if isPlatformAdmin() && 
        isValidInstituteData(request.resource.data);
      // Allow update/delete for:
      // 1. Main admin
      // 2. Users belonging to THIS institute  
      // 3. Authenticated users during registration (to update userCount/lastUserAdded only)
      // 4. Authenticated users who exist in users subcollection
      allow update: if (
        // Platform admin can update anything (with validation)
        (isPlatformAdmin() && 
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userCount', 'lastUserAdded']) ||
          isValidInstituteData(request.resource.data))) ||
        // Users belonging to institute can update anything (with validation)
        (belongsToInstitute(instituteId) && 
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userCount', 'lastUserAdded']) ||
          isValidInstituteData(request.resource.data))) ||
        // Allow authenticated users to update userCount/lastUserAdded during registration
        (isAuthenticated() && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userCount', 'lastUserAdded'])) ||
        // Allow authenticated users to update if they exist in users subcollection
        (isAuthenticated() && 
         exists(/databases/$(database)/documents/institutes/$(instituteId)/users/$(request.auth.uid)) &&
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userCount', 'lastUserAdded']) ||
          isValidInstituteData(request.resource.data)))
      );
      allow delete: if isPlatformAdmin();
      
      // Institute admins subcollection (everyone here is an admin)
      // FULL PERMISSIONS: Any authenticated admin can do everything
      match /users/{userId} {
        // Allow read for duplicate checks during registration (before user exists)
        // Also allow read for users belonging to institute
        // Note: Allowing reads for duplicate name checks during registration
        // This allows queries on name/nameLower fields for duplicate checking
        allow read: if belongsToInstitute(instituteId) || 
                      isPlatformAdmin() ||
                      // Allow authenticated users to read their own document
                      (isAuthenticated() && request.auth.uid == userId) ||
                      // Allow queries for duplicate checks (necessary for registration flow)
                      // Security note: This allows reading admin names, but not other sensitive data
                      true;
        allow create: if isPlatformAdmin() ||
          // Allow newly registered admin to create their own profile doc
          (isAuthenticated() &&
            request.auth.uid == userId &&
            request.resource.data.role == 'admin' &&
            request.resource.data.instituteId == instituteId);
        allow update: if belongsToInstitute(instituteId) || isPlatformAdmin();
        allow delete: if isPlatformAdmin();
      }
      
      // User credentials subcollection (for email sending)
      // FULL PERMISSIONS: Any authenticated admin can access
      match /user_credentials/{credId} {
        allow read, write: if request.auth != null;
      }
      
      // Batches subcollection - store batch definitions with name, year, timing, subjects
      match /batches/{batchId} {
        // FULL PERMISSIONS: Any authenticated admin can do everything
        allow read, write: if request.auth != null;
      }
      
      // Students subcollection
      match /students/{studentId} {
        // FULL PERMISSIONS: Any authenticated admin can do everything
        allow read, write: if request.auth != null;
      }
      
      // Attendance subcollection
      match /attendance/{attendanceId} {
        // FULL PERMISSIONS: Any authenticated admin can do everything
        // Once logged in, no restrictions - full access
        allow read, write: if request.auth != null;
      }
      
      // GPS settings subcollection
      // Path: institutes/{instituteId}/gps_settings/config
      // Lock policy:
      // - Unlocked config: institute admin or super admin can update
      // - Locked config: only super admin can update/unlock
      match /gps_settings/{gpsDocId} {
        // Testing mode: keep GPS settings writable for authenticated users
        // to avoid permission-denied during save/lock rollout.
        allow read, write: if request.auth != null;
      }
      
      // Batches subcollection - batches with name, year, timing, and subjects
      // Path: institutes/{instituteId}/batches/{batchId}
      match /batches/{batchId} {
        // FULL PERMISSIONS: Any authenticated admin can manage batches
        allow read, write: if request.auth != null;
      }
    }

    // ========== USERS COLLECTION (old structure - for backward compatibility only) ==========
    // NOTE: This should be phased out. New admins should be in institutes/{instituteId}/users
    match /users/{userId} {
      // Allow read for authenticated users (for backward compatibility during migration)
      // Also allow queries for duplicate checks during registration (before user is authenticated)
      // allow read covers both document reads and collection queries (list operations)
      // Note: Allowing unauthenticated reads for duplicate checks - this is necessary for registration flow
      allow read: if true;
      
      // Allow create/update/delete only for backward compatibility
      // New admins should be created in institute structure
      allow create: if isAuthenticated() || isMainAdmin();
      allow update: if isAuthenticated() && (
        request.auth.uid == userId ||
        isPlatformAdmin()
      );
      allow delete: if isAuthenticated() && isPlatformAdmin();
    }

    // ========== ATTENDANCE COLLECTION (old structure - for backward compatibility) ==========
    // NOTE: New attendance should be in institutes/{instituteId}/attendance
    match /attendance/{attendanceId} {
      allow read: if isAuthenticated() || isMainAdmin();
      allow write: if isAuthenticated() && isMainAdmin(); // Only main admin can write to old structure
    }

    // ========== SYSTEM SETTINGS COLLECTION (old structure - for backward compatibility) ==========
    // NOTE: New GPS settings should be in institutes/{instituteId}/gps_settings
    match /system_settings/{settingId} {
      allow read: if isAuthenticated() || isMainAdmin();
      allow write: if isAuthenticated() && isMainAdmin(); // Only main admin can write to old structure
    }

    // ========== ERROR LOGS COLLECTION (for coder dashboard) ==========
    match /error_logs/{errorId} {
      // Only coders can read error logs
      allow read: if isAuthenticated() && 
        exists(/databases/$(database)/documents/coders/$(request.auth.uid));
      // Any authenticated user can create error logs (for logging errors)
      // But only coders can update/delete (for resolving/deleting errors)
      allow create: if isAuthenticated();
      allow update, delete: if isAuthenticated() && 
        exists(/databases/$(database)/documents/coders/$(request.auth.uid));
    }

    // ========== CODERS COLLECTION (for coder authentication) ==========
    match /coders/{coderId} {
      // Coders can read their own data
      allow read: if isAuthenticated() && request.auth.uid == coderId;
      // Allow bootstrap for the primary super admin account by email
      // Note: set() with merge:true is treated as update, so we allow both create and update for bootstrap
      allow create: if isAuthenticated() &&
        request.auth.uid == coderId &&
        request.auth.token.email == 'digitrixmedia05@gmail.com';
      // Allow update for bootstrap (set with merge:true) and for main admin
      allow update: if (isAuthenticated() &&
        request.auth.uid == coderId &&
        request.auth.token.email == 'digitrixmedia05@gmail.com') ||
        isMainAdmin();
      // Only main admin can delete coders
      allow delete: if isMainAdmin();
    }
  }
}
