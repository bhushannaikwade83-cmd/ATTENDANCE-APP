rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user belongs to a specific institute
    // IMPORTANT: Admin IS the user - anyone in institutes/{instituteId}/users/{uid} is an admin of that institute
    // TESTING PHASE: Approval check removed - all users in institute can access
    function belongsToInstitute(instituteId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/institutes/$(instituteId)/users/$(request.auth.uid));
    }
    
    // Helper function to check if user is main admin (super admin control panel)
    function isMainAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/main_admins/$(request.auth.uid));
    }

    // Helper function to validate email format
    function isValidEmail(email) {
      return email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }

    // Helper function to validate string length
    function isValidLength(str, minLen, maxLen) {
      return str is string && str.size() >= minLen && str.size() <= maxLen;
    }

    // Helper function to validate roll number format
    function isValidRollNumber(rollNumber) {
      return rollNumber is string && 
             rollNumber.matches('^[A-Za-z0-9_-]{1,20}$');
    }

    // Helper function to validate name format
    function isValidName(name) {
      return name is string && 
             name.size() >= 2 && 
             name.size() <= 100 &&
             name.matches('^[a-zA-Z\\s\\.]{1,100}$');
    }

    // Helper function to validate institute data
    function isValidInstituteData(data) {
      return isValidLength(data.name, 2, 100) &&
             isValidLength(data.instituteId, 1, 50) &&
             data.instituteId.matches('^[A-Za-z0-9_-]{1,50}$');
    }

    // Helper function to validate student data
    function isValidStudentData(data) {
      // Check required fields exist and are valid
      return data.name is string &&
             isValidName(data.name) &&
             data.userId is string &&
             isValidRollNumber(data.userId) &&
             // Optional batchName - allow null, empty string, or valid length
             (data.batchName == null || 
              (data.batchName is string && 
               (data.batchName.size() == 0 || isValidLength(data.batchName, 1, 50)))) &&
             // Optional email - allow null, empty string, or valid email format
             (data.email == null || 
              (data.email is string && 
               (data.email.size() == 0 || isValidEmail(data.email))));
    }

    // Helper function to validate attendance data
    function isValidAttendanceData(data) {
      // Required fields: rollNumber and subject must be valid strings
      // Timestamp validation: serverTimestamp() sentinels are handled by Firestore
      // We check if timestamp exists (it will be converted to timestamp on server)
      return data.rollNumber is string &&
             isValidRollNumber(data.rollNumber) &&
             data.subject is string &&
             isValidLength(data.subject, 1, 50) &&
             // Timestamp: can be timestamp type or serverTimestamp sentinel (Firestore handles conversion)
             // We just check that the field exists - Firestore will convert serverTimestamp() to actual timestamp
             data.keys().hasAny(['timestamp']) &&
             // Optional fields
             (data.photoUrl == null || (data.photoUrl is string && data.photoUrl.size() > 0)) &&
             (data.studentName == null || (data.studentName is string && isValidName(data.studentName))) &&
             (data.date == null || (data.date is string && data.date.size() > 0));
    }
    
    // ========== MAIN ADMINS COLLECTION ==========
    match /main_admins/{adminId} {
      // Main admin can read their own data
      allow read: if isAuthenticated() && request.auth.uid == adminId;
      // Only server/admin SDK can write (for security)
      allow write: if false;
    }
    
    // ========== INSTITUTES COLLECTION ==========
    match /institutes/{instituteId} {
      // Institute document - readable by anyone (authenticated or not) for search
      // This allows users to search institutes before registration
      // allow read covers both document reads and collection queries
      allow read: if true;
      // ONLY main admin (super admin) can create institutes
      allow create: if isMainAdmin() && 
        isValidInstituteData(request.resource.data);
      // Allow update/delete for:
      // 1. Main admin
      // 2. Users belonging to THIS institute  
      // 3. Authenticated users during registration (to update userCount)
      //    Note: User document is created first, then institute is updated, so user exists by then
      allow update: if (isMainAdmin() || 
        belongsToInstitute(instituteId) ||
        // Allow authenticated users to update institute if they exist in users subcollection
        (isAuthenticated() && 
         exists(/databases/$(database)/documents/institutes/$(instituteId)/users/$(request.auth.uid)))) &&
        // Validate data on update (allow userCount updates without full validation)
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userCount']) ||
         isValidInstituteData(request.resource.data));
      allow delete: if isMainAdmin();
      
      // Institute admins subcollection (everyone here is an admin)
      // FULL PERMISSIONS: Any authenticated admin can do everything
      match /users/{userId} {
        // Full access for authenticated users
        allow read: if true || request.auth != null;
        allow create: if request.auth != null;
        allow update: if request.auth != null;
        allow delete: if request.auth != null;
      }
      
      // User credentials subcollection (for email sending)
      // FULL PERMISSIONS: Any authenticated admin can access
      match /user_credentials/{credId} {
        allow read, write: if request.auth != null;
      }
      
      // Batches subcollection - store batch definitions with name, year, timing, subjects
      match /batches/{batchId} {
        // FULL PERMISSIONS: Any authenticated admin can do everything
        allow read, write: if request.auth != null;
      }
      
      // Students subcollection
      match /students/{studentId} {
        // FULL PERMISSIONS: Any authenticated admin can do everything
        allow read, write: if request.auth != null;
      }
      
      // Attendance subcollection
      match /attendance/{attendanceId} {
        // FULL PERMISSIONS: Any authenticated admin can do everything
        // Once logged in, no restrictions - full access
        allow read, write: if request.auth != null;
      }
      
      // GPS settings subcollection - each admin has their own GPS settings
      // Path: institutes/{instituteId}/gps_settings/{adminId}
      // FULL PERMISSIONS: Any authenticated admin can access any GPS settings
      match /gps_settings/{adminId} {
        allow read, write: if request.auth != null;
      }
      
      // Batches subcollection - batches with name, year, timing, and subjects
      // Path: institutes/{instituteId}/batches/{batchId}
      match /batches/{batchId} {
        // FULL PERMISSIONS: Any authenticated admin can manage batches
        allow read, write: if request.auth != null;
      }
    }

    // ========== USERS COLLECTION (old structure - for backward compatibility only) ==========
    // NOTE: This should be phased out. New admins should be in institutes/{instituteId}/users
    match /users/{userId} {
      // Allow read for authenticated users (for backward compatibility during migration)
      // allow read covers both document reads and collection queries (list operations)
      allow read: if isAuthenticated() || isMainAdmin();
      
      // Allow create/update/delete only for backward compatibility
      // New admins should be created in institute structure
      allow create: if isAuthenticated() || isMainAdmin();
      allow update: if isAuthenticated() && (
        request.auth.uid == userId ||
        isMainAdmin()
      );
      allow delete: if isAuthenticated() && isMainAdmin();
    }

    // ========== ATTENDANCE COLLECTION (old structure - for backward compatibility) ==========
    // NOTE: New attendance should be in institutes/{instituteId}/attendance
    match /attendance/{attendanceId} {
      allow read: if isAuthenticated() || isMainAdmin();
      allow write: if isAuthenticated() && isMainAdmin(); // Only main admin can write to old structure
    }

    // ========== SYSTEM SETTINGS COLLECTION (old structure - for backward compatibility) ==========
    // NOTE: New GPS settings should be in institutes/{instituteId}/gps_settings
    match /system_settings/{settingId} {
      allow read: if isAuthenticated() || isMainAdmin();
      allow write: if isAuthenticated() && isMainAdmin(); // Only main admin can write to old structure
    }

    // ========== ERROR LOGS COLLECTION (for coder dashboard) ==========
    match /error_logs/{errorId} {
      // Only coders can read error logs
      allow read: if isAuthenticated() && 
        exists(/databases/$(database)/documents/coders/$(request.auth.uid));
      // Any authenticated user can create error logs (for logging errors)
      // But only coders can update/delete (for resolving/deleting errors)
      allow create: if isAuthenticated();
      allow update, delete: if isAuthenticated() && 
        exists(/databases/$(database)/documents/coders/$(request.auth.uid));
    }

    // ========== CODERS COLLECTION (for coder authentication) ==========
    match /coders/{coderId} {
      // Coders can read their own data
      allow read: if isAuthenticated() && request.auth.uid == coderId;
      // Only main admin can create/update/delete coders
      allow write: if isMainAdmin();
    }
  }
}